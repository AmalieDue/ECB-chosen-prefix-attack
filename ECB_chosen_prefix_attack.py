# -*- coding: utf-8 -*-
"""Week 7 Modern Cryptology - Modes of Operation - Exercises.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uuOzB8vVTZHUW2SYop6deLvpUM2v2zGf
"""

"""Code for Exercise 1 on Exercise sheet 5."""


"""Code for Exercise 3 on Exercise sheet 5."""
import base64

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import binascii


def main():
    """Use `encrypt` to determine the SECRET bytes."""
    
    lengthOfSecret = guessNumberOfBytesInSecret()
    #print("Length of Secret = " + str(lengthOfSecret))
    
    currentSecretGuess = [0]*15
    Secret=[]
    
    
    #Guess the first block
    for j in range(16):
        
      guess = currentSecretGuess[-15:]
      correctGuess = 266
      
      for i in range(256):
        guess.append(i)
        guess = guess + [0]*(15-j) 
         
        c = encrypt(bytes(guess))
        listOfEnc = list(c)
        part1 = listOfEnc[0:16]
        part2 = listOfEnc[16:32]
        
        if(part1 == part2):
          correctGuess = i
          Secret.append(correctGuess)
          currentSecretGuess.append(correctGuess)
          break    
        else:
          guess = currentSecretGuess[-15:]
      
   # print(Secret)
    #print(len(Secret))
    
    #Guess the second block
    Check=[]
    for j in range(16,lengthOfSecret): 
        guess = Secret[-15:]
        Block=int(j/16)+1
       
        
        for i in range(256):
            
            guess.append(i)
            guess=guess+[0]*(15-j%16)
            
            
            c = encrypt(bytes(guess))
            listOfEnc = list(c)
            part1 = listOfEnc[0:16]
            Check.append(part1)
            #print(part1)
            part2 = listOfEnc[16*Block:16*(Block+1)]
            
            if(part1 == part2):
                correctGuess = i
                Secret.append(correctGuess)
                currentSecretGuess.append(correctGuess)
                break  
            else:
                guess = Secret[-15:]
    
    
    hex_string = "".join("%02x" % b for b in Secret)

    print(binascii.unhexlify(hex_string))
    
        

def guessNumberOfBytesInSecret():
    lengthOfEncryption = len(encrypt(bytes("",'utf-8')))
    temp = lengthOfEncryption
    i = 1
    while(temp == lengthOfEncryption):
      temp = len(encrypt(bytes([0]*i)))
      i = i + 1
    return (lengthOfEncryption - i +1)

KEY = get_random_bytes(16)
SECRET = (
    b"WWVzdGVyZGF5LCBhbGwgbXkgdHJvdWJsZXMgc2VlbWVkIHNvIGZhciBhd2F5IE"
    b"5vdyBpdCBsb29rcyBhcyB0aG91Z2ggdGhleSdyZSBoZXJlIHRvIHN0YXkgT2gs"
    b"IEkgYmVsaWV2ZSBpbiB5ZXN0ZXJkYXk="
)





def encrypt(plaintext: bytes):
    """Encrypt the plaintext + SECRET with an unknown key in ECB mode."""
    cipher = AES.new(KEY, AES.MODE_ECB)
    secret = base64.b64decode(SECRET)
    padded_text = pkcs7_pad(plaintext + secret, 16)
    return cipher.encrypt(padded_text)


def pkcs7_pad(message: bytes, bytes_per_block: int) -> bytes:
    """Return the message padded to a multiple of `bytes_per_block`."""
    if bytes_per_block >= 256 or bytes_per_block < 1:
        raise Exception("Invalid padding modulus")
    remainder = len(message) % bytes_per_block
    padding_length = bytes_per_block - remainder
    padding = bytes([padding_length] * padding_length)
    return message + padding


if __name__ == "__main__":
    main()